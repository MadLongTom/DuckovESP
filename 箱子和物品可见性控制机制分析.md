# 箱子和物品可见性控制机制分析

## 📋 核心组件

### 1. **SetActiveByCondition** 组件
控制 GameObject 的激活状态（`SetActive(true/false)`）

**工作原理**:
```csharp
public class SetActiveByCondition : MonoBehaviour
{
    public GameObject targetObject;           // 要控制的目标对象
    public bool inverse;                      // 是否反转条件结果
    public List<Condition> conditions;        // 条件列表
    public bool update;                       // 是否持续检查
    private float checkTimeSpace = 1f;        // 检查间隔（1秒）
    
    private void Update()
    {
        // 在关卡初始化后才检查
        if (!LevelManager.LevelInited && this.requireLevelInited)
            return;
            
        // 评估所有条件
        bool satisfied = conditions.Satisfied();
        if (inverse)
            satisfied = !satisfied;
            
        targetObject.SetActive(satisfied);
        
        // 如果需要持续更新，1秒后再次检查
        if (update)
            CheckAndLoop();
            
        enabled = false; // 单次检查后禁用自己
    }
}
```

**条件评估逻辑**:
```csharp
// 所有条件都必须满足（AND 逻辑）
public static bool Satisfied(this IEnumerable<Condition> conditions)
{
    foreach (Condition condition in conditions)
    {
        if (condition == null) continue;
        if (!condition.Evaluate())  // 任何一个不满足就返回 false
            return false;
    }
    return true;
}
```

---

### 2. **Condition** 基类和派生类
定义各种条件判断逻辑

**基类**:
```csharp
public class Condition : MonoBehaviour
{
    public virtual bool Evaluate()
    {
        return false;
    }
}
```

**常见派生类**:

#### 任务相关:
- **RequireQuestsActive**: 任务激活时满足
  ```csharp
  public override bool Evaluate()
  {
      return QuestManager.AreQuestsActive(requiredQuestIDs);
  }
  ```

- **RequireQuestsFinished**: 任务完成时满足
  ```csharp
  public override bool Evaluate()
  {
      return QuestManager.AreQuestFinished(requiredQuestIDs);
  }
  ```

#### 配方/蓝图相关:
- **RequireFormulaUnlocked**: 配方解锁时满足
  ```csharp
  public override bool Evaluate()
  {
      return CraftingManager.IsFormulaUnlocked(formulaID);
  }
  ```

- **RequirePerkUnlocked**: 技能解锁时满足

#### 其他:
- **Condition_TimeOfDay**: 特定时间段
- **Condition_CharacterLevel**: 角色等级要求
- **Condition_RaidDead**: RAID 失败状态
- **Condition_HasBeenToScene**: 访问过特定场景
- **RequireWeathers**: 特定天气
- **RequireBeaconUnlocked**: 信标解锁
- **RequireEnemyKilled**: 敌人被击杀

---

### 3. **LootBoxLoader** 组件
控制箱子的生成和内容

**关键功能**:

#### A. 随机激活（概率生成）
```csharp
[Range(0f, 1f)]
private float activeChance = 1f;  // 箱子生成概率

private void RandomActive()
{
    int key = GetKey();  // 基于位置的唯一Key
    
    // 检查是否已有缓存决策
    if (MultiSceneCore.Instance.inLevelData.TryGetValue(key, out obj))
    {
        flag = (bool)obj;  // 使用缓存的激活状态
    }
    else
    {
        // 第一次生成，掷骰子决定
        flag = Random.Range(0f, 1f) < activeChance;
        MultiSceneCore.Instance.inLevelData.Add(key, flag);  // 缓存决策
    }
    
    gameObject.SetActive(flag);  // 设置激活状态
}
```

**重要特性**:
- 使用 `inLevelData` 缓存激活状态（同一关卡内保持一致）
- 不同关卡、不同存档可能有不同的生成结果
- `activeChance = 0.5` 表示 50% 概率生成

#### B. 物品生成
```csharp
public async UniTask Setup()
{
    // 随机生成物品数量
    int num = Random.Range(randomCount.x, randomCount.y) * LootboxItemCountMultiplier;
    
    // 生成固定物品（可选）
    if (Random.Range(0f, 1f) < fixedItemSpawnChance)
        list.AddRange(fixedItems);
    
    // 生成随机物品
    for (int i = 0; i < num; i++)
    {
        // 从物品池或标签池中随机选择
        // ...
    }
    
    // 添加到 Inventory
    foreach (int itemID in list)
    {
        Item item = await ItemAssetsCollection.InstantiateAsync(itemID);
        Inventory.AddItem(item);
    }
    
    Inventory.Loading = false;
    _lootBox.CheckHideIfEmpty();  // 检查是否为空箱子
}
```

---

## 🎯 箱子/物品不可见的典型场景

### 场景 1: 任务锁定的箱子
```
GameObject: "QuestLootbox"
├─ InteractableLootbox
├─ LootBoxLoader
│  └─ activeChance = 1.0
└─ SetActiveByCondition
   ├─ targetObject = this.gameObject
   ├─ inverse = false
   ├─ update = true
   └─ conditions:
      └─ RequireQuestsActive
         └─ requiredQuestIDs = [101, 102]
```

**行为**:
- 任务 101 和 102 都激活时 → 箱子可见
- 任务未开始或已完成 → 箱子不可见
- 每秒检查一次任务状态（`update = true`）

---

### 场景 2: 蓝图锁定的物品
```
GameObject: "BlueprintItem"
├─ DuckovItemAgent (pickUp类型)
├─ Item
└─ SetActiveByCondition
   ├─ targetObject = this.gameObject
   ├─ inverse = false
   └─ conditions:
      └─ RequireFormulaUnlocked
         └─ formulaID = "GunBlueprint_AK47"
```

**行为**:
- 玩家未解锁配方 → 物品不可见
- 玩家解锁配方后 → 物品可见
- 全局只能捡一次（捡起后自动销毁）

---

### 场景 3: 概率生成的箱子
```
GameObject: "RandomLootbox"
├─ InteractableLootbox
└─ LootBoxLoader
   └─ activeChance = 0.3
```

**行为**:
- 关卡加载时 30% 概率生成
- 一旦决定不生成，整个关卡周期内都不会出现
- 重新加载关卡可能改变生成结果

---

### 场景 4: 多重条件复合
```
GameObject: "AdvancedLootbox"
├─ InteractableLootbox
├─ LootBoxLoader
│  └─ activeChance = 0.5
└─ SetActiveByCondition
   ├─ conditions:
   │  ├─ RequireQuestsFinished [201]
   │  ├─ Condition_CharacterLevel (min = 10)
   │  └─ RequireBeaconUnlocked
   └─ update = false
```

**行为**:
1. 首先 50% 概率决定是否生成（LootBoxLoader）
2. 如果生成，检查三个条件：
   - 任务 201 必须完成
   - 角色等级 ≥ 10
   - 信标已解锁
3. 所有条件满足 → 箱子可见

---

## 🔍 为什么我们的过滤还不够？

### 当前过滤逻辑:
```csharp
// LootboxDataCollector.cs
if (!lootbox.gameObject.activeInHierarchy)  // ✅ 能过滤
    continue;

if (!lootbox.enabled)  // ✅ 能过滤
    continue;
```

### 问题分析:

#### 问题 1: SetActiveByCondition 的延迟生效
```csharp
private void Update()
{
    if (!LevelManager.LevelInited && this.requireLevelInited)
        return;  // 关卡未初始化时不检查
        
    this.Set();  // 第一次设置激活状态
    enabled = false;  // 禁用自己
}
```

**时序问题**:
```
1. 关卡开始加载
2. LootboxDataCollector.ScanExistingLootboxes() 执行  ← 此时 GameObject 可能还是 active
3. LevelManager.LevelInited = true
4. SetActiveByCondition.Update() 执行  ← 现在才设置 active 状态
5. 箱子被禁用，但已经被追踪了
```

#### 问题 2: update = true 的动态变化
```csharp
if (this.update)
{
    CheckAndLoop();  // 每秒检查一次
}
```

**动态问题**:
- 任务状态随时可能改变
- 箱子可能在游戏过程中动态出现/消失
- 我们的扫描只在关卡初始化时执行一次

---

## 💡 建议的完整解决方案

### 方案 A: 延迟扫描（简单）
```csharp
private void ScanExistingLootboxes()
{
    // 等待关卡完全初始化
    await UniTask.WaitUntil(() => LevelManager.LevelInited);
    
    // 再等一帧，确保所有 SetActiveByCondition 都执行完
    await UniTask.Yield();
    
    // 现在开始扫描
    var allLootboxes = FindObjectsOfType<InteractableLootbox>();
    foreach (var lootbox in allLootboxes)
    {
        if (!lootbox.gameObject.activeInHierarchy)
            continue;  // 现在能正确过滤了
        
        ProcessLootbox(lootbox);
    }
}
```

### 方案 B: 监听动态变化（完整）
```csharp
// 1. 在 LootboxDataCollector 中添加定期检查
private async UniTaskVoid MonitorLootboxVisibility()
{
    while (_isInitialized)
    {
        await UniTask.WaitForSeconds(1f);  // 每秒检查
        
        // 检查所有已追踪的箱子
        var toRemove = new List<InteractableLootbox>();
        foreach (var kvp in _trackedLootboxes)
        {
            var lootbox = kvp.Key;
            if (lootbox == null || !lootbox.gameObject.activeInHierarchy)
            {
                toRemove.Add(lootbox);
            }
        }
        
        // 移除不可见的箱子
        foreach (var lootbox in toRemove)
        {
            RemoveLootbox(lootbox);
        }
        
        // 扫描新出现的箱子
        ScanForNewLootboxes();
    }
}

// 2. 在 MinimapMarkerService 中订阅 LootboxRemovedEvent
```

### 方案 C: 检查 SetActiveByCondition 组件（精确）
```csharp
private bool ShouldTrackLootbox(InteractableLootbox lootbox)
{
    // 基础检查
    if (lootbox == null || !lootbox.gameObject.activeInHierarchy)
        return false;
    
    if (!lootbox.enabled)
        return false;
    
    // 检查是否有 SetActiveByCondition 组件
    var conditionComponent = lootbox.GetComponent<SetActiveByCondition>();
    if (conditionComponent != null)
    {
        // 手动评估条件
        bool satisfied = conditionComponent.conditions.Satisfied();
        if (conditionComponent.inverse)
            satisfied = !satisfied;
        
        if (!satisfied)
        {
            _logger.Debug($"箱子条件不满足: {lootbox.name}");
            return false;
        }
    }
    
    // 检查 LootBoxLoader 的概率生成
    var loader = lootbox.GetComponent<LootBoxLoader>();
    if (loader != null)
    {
        // activeChance 已经在 Awake 中处理，这里只检查结果
        if (!lootbox.gameObject.activeSelf)
            return false;
    }
    
    return true;
}
```

---

## 📊 推荐实施方案

结合简单性和有效性，推荐 **方案 A + 优化的初始检查**:

```csharp
// 1. 延迟初始扫描
public async void Initialize()
{
    // 等待关卡初始化
    await UniTask.WaitUntil(() => LevelManager.LevelInited);
    
    // 等待一帧让所有 SetActiveByCondition 执行
    await UniTask.Yield();
    
    // 现在扫描
    ScanExistingLootboxes();
    
    // 订阅 Hook
    LootboxSpawnHook.OnLootboxSpawned += HandleLootboxSpawned;
}

// 2. 动态生成的箱子检查
private void HandleLootboxSpawned(InteractableLootbox lootbox)
{
    if (lootbox == null || !lootbox.gameObject.activeInHierarchy)
        return;
    
    if (!lootbox.enabled)
        return;
    
    // 对于动态生成的箱子，等待一帧再检查
    await UniTask.Yield();
    
    if (!lootbox.gameObject.activeInHierarchy)
        return;  // 可能被 SetActiveByCondition 禁用了
    
    ProcessLootbox(lootbox);
}
```

这样可以：
- ✅ 过滤掉任务锁定的箱子
- ✅ 过滤掉蓝图锁定的物品
- ✅ 过滤掉概率未生成的箱子
- ✅ 过滤掉多重条件不满足的对象
- ✅ 保持代码简洁，性能开销小
